!function (e) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).Egua = e() } }(function () { var e = function (e) { var t; return function (r) { return t || e(t = { exports: {}, parent: r }, t.exports), t.exports } }, t = e(function (e, t) { const i = r({}), { RuntimeError: n, ContinueException: o, BreakException: a, ReturnException: h } = q; e.exports = class e { constructor(e, t) { this.Egua = e, this.baseDir = t, this.globals = new Z, this.environment = this.globals, this.locals = new Map, this.globals = Re(this.globals) } resolve(e, t) { this.locals.set(e, t) } visitLiteralExpr(e) { return e.value } evaluate(e) { return e.accept(this) } visitGroupingExpr(e) { return this.evaluate(e.expression) } isTruthy(e) { return null !== e && ("boolean" != typeof e || Boolean(e)) } checkNumberOperand(e, t) { if ("number" != typeof t) throw new n(e, "Operador precisa ser um n\xfamero.") } visitUnaryExpr(e) { let t = this.evaluate(e.right); switch (e.operator.type) { case s.MINUS: return this.checkNumberOperand(e.operator, t), -t; case s.BANG: return !this.isTruthy(t); case s.BIT_NOT: return ~t }return null } isEqual(e, t) { return null === e && null === t || null !== e && e === t } checkNumberOperands(e, t, r) { if ("number" != typeof t || "number" != typeof r) throw new n(e, "Operadores precisam ser n\xfameros.") } visitBinaryExpr(e) { let t = this.evaluate(e.left), r = this.evaluate(e.right); switch (e.operator.type) { case s.STAR_STAR: return this.checkNumberOperands(e.operator, t, r), Math.pow(t, r); case s.GREATER: return this.checkNumberOperands(e.operator, t, r), Number(t) > Number(r); case s.GREATER_EQUAL: return this.checkNumberOperands(e.operator, t, r), Number(t) >= Number(r); case s.LESS: return this.checkNumberOperands(e.operator, t, r), Number(t) < Number(r); case s.LESS_EQUAL: return this.checkNumberOperands(e.operator, t, r), Number(t) <= Number(r); case s.MINUS: return this.checkNumberOperands(e.operator, t, r), Number(t) - Number(r); case s.PLUS: if ("number" == typeof t && "number" == typeof r) return Number(t) + Number(r); if ("string" == typeof t && "string" == typeof r) return String(t) + String(r); throw new n(e.operator, "Operadores precisam ser dois n\xfameros ou duas strings."); case s.SLASH: return this.checkNumberOperands(e.operator, t, r), Number(t) / Number(r); case s.STAR: return this.checkNumberOperands(e.operator, t, r), Number(t) * Number(r); case s.MODULUS: return this.checkNumberOperands(e.operator, t, r), Number(t) % Number(r); case s.BIT_AND: return this.checkNumberOperands(e.operator, t, r), Number(t) & Number(r); case s.BIT_XOR: return this.checkNumberOperands(e.operator, t, r), Number(t) ^ Number(r); case s.BIT_OR: return this.checkNumberOperands(e.operator, t, r), Number(t) | Number(r); case s.LESSER_LESSER: return this.checkNumberOperands(e.operator, t, r), Number(t) << Number(r); case s.GREATER_GREATER: return this.checkNumberOperands(e.operator, t, r), Number(t) >> Number(r); case s.BANG_EQUAL: return !this.isEqual(t, r); case s.EQUAL_EQUAL: return this.isEqual(t, r) }return null } visitCallExpr(e) { let t, r = this.evaluate(e.callee), s = []; for (let i = 0; i < e.args.length; i++)s.push(this.evaluate(e.args[i])); if (!(r instanceof me)) throw new n(e.paren, "S\xf3 pode chamar fun\xe7\xe3o ou classe."); if (t = r instanceof Ee ? r.declaration.params : r instanceof Ae && r.methods.init ? r.methods.init.declaration.params : [], s.length < r.arity()) { let e = r.arity() - s.length; for (let t = 0; t < e; t++)s.push(null) } else if (s.length >= r.arity() && t.length > 0 && "wildcard" === t[t.length - 1].type) { let e = s.slice(0, t.length - 1); e.push(s.slice(t.length - 1, s.length)), s = e } return r instanceof ve ? r.call(this, s, e.callee.name) : r.call(this, s) } visitAssignExpr(e) { let t = this.evaluate(e.value), r = this.locals.get(e); return void 0 !== r ? this.environment.assignVarAt(r, e.name, t) : this.environment.assignVar(e.name, t), t } lookupVar(e, t) { let r = this.locals.get(t); return void 0 !== r ? this.environment.getVarAt(r, e.lexeme) : this.globals.getVar(e) } visitVariableExpr(e) { return this.lookupVar(e.name, e) } visitExpressionStmt(e) { return this.evaluate(e.expression), null } visitLogicalExpr(e) { let t = this.evaluate(e.left); if (e.operator.type === s.EM) { let r = this.evaluate(e.right); if (Array.isArray(r) || "string" == typeof r) return r.includes(t); if (r.constructor == Object) return t in r; throw new n("Tipo de chamada inv\xe1lida com 'em'.") } return e.operator.type === s.OU && this.isTruthy(t) ? t : e.operator.type !== s.E || this.isTruthy(t) ? this.evaluate(e.right) : t } visitIfStmt(e) { if (this.isTruthy(this.evaluate(e.condition))) return this.execute(e.thenBranch), null; for (let t = 0; t < e.elifBranches.length; t++) { let r = e.elifBranches[t]; if (this.isTruthy(this.evaluate(r.condition))) return this.execute(r.branch), null } return null !== e.elseBranch && this.execute(e.elseBranch), null } visitForStmt(e) { for (null !== e.initializer && this.evaluate(e.initializer); null === e.condition || this.isTruthy(this.evaluate(e.condition));) { try { this.execute(e.body) } catch (error) { if (error instanceof a) break; if (!(error instanceof o)) throw error } null !== e.increment && this.evaluate(e.increment) } return null } visitDoStmt(e) { do { try { this.execute(e.doBranch) } catch (error) { if (error instanceof a) break; if (!(error instanceof o)) throw error } } while (this.isTruthy(this.evaluate(e.whileCondition))) } visitSwitchStmt(e) { let t = this.evaluate(e.condition), r = e.branches, s = e.defaultBranch, i = !1; try { for (let e = 0; e < r.length; e++) { let s = r[e]; for (let e = 0; e < s.conditions.length; e++)if (this.evaluate(s.conditions[e]) === t) { i = !0; try { for (let e = 0; e < s.stmts.length; e++)this.execute(s.stmts[e]) } catch (error) { if (!(error instanceof o)) throw error } } } if (null !== s && !1 === i) for (let e = 0; e < s.stmts.length; e++)this.execute(s.stmts[e]) } catch (error) { if (!(error instanceof a)) throw error } } visitTryStmt(e) { try { let t = !0; try { this.executeBlock(e.tryBranch, new Z(this.environment)) } catch (error) { t = !1, null !== e.catchBranch && this.executeBlock(e.catchBranch, new Z(this.environment)) } t && null !== e.elseBranch && this.executeBlock(e.elseBranch, new Z(this.environment)) } finally { null !== e.finallyBranch && this.executeBlock(e.finallyBranch, new Z(this.environment)) } } visitWhileStmt(e) { for (; this.isTruthy(this.evaluate(e.condition));)try { this.execute(e.body) } catch (error) { if (error instanceof a) break; if (!(error instanceof o)) throw error } return null } visitImportStmt(t) { let r = this.evaluate(t.path), s = ue.join(this.baseDir, r), o = ue.dirname(s), a = ue.basename(s), h = xe(r); if (null !== h) return h; try { if (!pe.existsSync(s)) throw new n(t.closeBracket, "N\xe3o foi poss\xedvel encontrar arquivo importado.") } catch (error) { throw new n(t.closeBracket, "N\xe3o foi poss\xedvel ler o arquivo.") } h = pe.readFileSync(s).toString(); const c = new i.Egua(a), l = new e(c, o); c.run(h, l); let u = l.globals.values.exports; if ((e => e.constructor === Object)(u)) { let e = new Te, t = Object.keys(u); for (let r = 0; r < t.length; r++)e[t[r]] = u[t[r]]; return e } return u } visitPrintStmt(e) { let t = this.evaluate(e.expression); return console.log(this.stringify(t)), null } executeBlock(e, t) { let r = this.environment; try { this.environment = t; for (let t = 0; t < e.length; t++)this.execute(e[t]) } finally { this.environment = r } } visitBlockStmt(e) { return this.executeBlock(e.statements, new Z(this.environment)), null } visitVarStmt(e) { let t = null; return null !== e.initializer && (t = this.evaluate(e.initializer)), this.environment.defineVar(e.name.lexeme, t), null } visitContinueStmt(e) { throw new o } visitBreakStmt(e) { throw new a } visitReturnStmt(e) { let t = null; throw null != e.value && (t = this.evaluate(e.value)), new h(t) } visitFunctionExpr(e) { return new Ee(null, e, this.environment, !1) } visitAssignsubscriptExpr(e) { let t = this.evaluate(e.obj), r = this.evaluate(e.index), s = this.evaluate(e.value); if (Array.isArray(t)) { if (r < 0 && 0 !== t.length) for (; r < 0;)r += t.length; for (; t.length < r;)t.push(null); t[r] = s } else { if (!(t.constructor == Object || t instanceof fe || t instanceof Ee || t instanceof Ae || t instanceof Te)) throw new n(e.obj.name, "Somente listas, dicion\xe1rios, classes e objetos podem ser mudados por sobrescrita."); t[r] = s } } visitSubscriptExpr(e) { let t = this.evaluate(e.callee), r = this.evaluate(e.index); if (Array.isArray(t)) { if (!Number.isInteger(r)) throw new n(e.closeBracket, "Somente inteiros podem ser usados para indexar um vetor."); if (r < 0 && 0 !== t.length) for (; r < 0;)r += t.length; if (r >= t.length) throw new n(e.closeBracket, "Index do vetor fora do intervalo."); return t[r] } if (t.constructor == Object || t instanceof fe || t instanceof Ee || t instanceof Ae || t instanceof Te) return t[r] || null; if ("string" == typeof t) { if (!Number.isInteger(r)) throw new n(e.closeBracket, "Somente inteiros podem ser usados para indexar um vetor."); if (r < 0 && 0 !== t.length) for (; r < 0;)r += t.length; if (r >= t.length) throw new n(e.closeBracket, "Index fora do tamanho."); return t.charAt(r) } throw new n(e.callee.name, "Somente listas, dicion\xe1rios, classes e objetos podem ser mudados por sobrescrita.") } visitSetExpr(e) { let t = this.evaluate(e.object); if (!(t instanceof fe) && t.constructor !== Object) throw new n(e.object.name, "Somente inst\xe2ncias e dicion\xe1rios podem possuir campos."); let r = this.evaluate(e.value); if (t instanceof fe) return t.set(e.name, r), r; t.constructor == Object && (t[e.name.lexeme] = r) } visitFunctionStmt(e) { let t = new Ee(e.name.lexeme, e.func, this.environment, !1); this.environment.defineVar(e.name.lexeme, t) } visitClassStmt(e) { let t = null; if (null !== e.superclass && !((t = this.evaluate(e.superclass)) instanceof Ae)) throw new n(e.superclass.name, "Superclasse precisa ser uma classe."); this.environment.defineVar(e.name.lexeme, null), null !== e.superclass && (this.environment = new Z(this.environment), this.environment.defineVar("super", t)); let r = {}, s = e.methods; for (let n = 0; n < e.methods.length; n++) { let e = s[n], t = "construtor" === e.name.lexeme, i = new Ee(e.name.lexeme, e.func, this.environment, t); r[e.name.lexeme] = i } let i = new Ae(e.name.lexeme, t, r); return null !== t && (this.environment = this.environment.enclosing), this.environment.assignVar(e.name, i), null } visitGetExpr(e) { let t = this.evaluate(e.object); if (t instanceof fe) return t.get(e.name) || null; if (t.constructor == Object) return t[e.name.lexeme] || null; if (t instanceof Te) return t[e.name.lexeme] || null; throw new n(e.name, "Voc\xea s\xf3 pode acessar m\xe9todos do objeto e dicion\xe1rios.") } visitThisExpr(e) { return this.lookupVar(e.keyword, e) } visitDictionaryExpr(e) { let t = {}; for (let r = 0; r < e.keys.length; r++)t[this.evaluate(e.keys[r])] = this.evaluate(e.values[r]); return t } visitArrayExpr(e) { let t = []; for (let r = 0; r < e.values.length; r++)t.push(this.evaluate(e.values[r])); return t } visitSuperExpr(e) { let t = this.locals.get(e), r = this.environment.getVarAt(t, "super"), s = this.environment.getVarAt(t - 1, "isto"), i = r.findMethod(e.method.lexeme); if (void 0 === i) throw new n(e.method, "M\xe9todo chamado indefinido."); return i.bind(s) } stringify(e) { return null === e ? "nulo" : Array.isArray(e) ? e : e.toString() } execute(e) { e.accept(this) } interpret(e) { try { for (let t = 0; t < e.length; t++)this.execute(e[t]) } catch (error) { this.Egua.runtimeError(error) } } } }), r = e(function (e, r) { (function (r) { const i = t({}); e.exports.Egua = class { constructor(e) { this.filename = e, this.hadError = !1, this.hadRuntimeError = !1 } runPrompt() { const e = new i(this, r.cwd(), void 0), t = pe.createInterface({ input: r.stdin, output: r.stdout, prompt: ">>> " }); t.prompt(), t.on("line", r => { this.hadError = !1, this.hadRuntimeError = !1, this.run(r, e), t.prompt() }) } runfile(e) { this.filename = ue.basename(e); const t = new i(this, r.cwd()), s = pe.readFileSync(e).toString(); this.run(s, t), this.hadError && r.exit(65), this.hadRuntimeError && r.exit(70) } run(e, t) { const r = new o(e, this).scan(); if (!0 === this.hadError) return; const s = new Q(r, this).parse(); !0 !== this.hadError && (new z(t, this).resolve(s), !0 !== this.hadError && t.interpret(s)) } report(e, t, r) { this.filename ? console.error(`[Arquivo: ${this.filename}] [Linha: ${e}] Erro${t}: ${r}`) : console.error(`[Linha: ${e}] Erro${t}: ${r}`), this.hadError = !0 } error(e, t) { e.type === s.EOF ? this.report(e.line, " no final", t) : this.report(e.line, ` no '${e.lexeme}'`, t) } lexerError(e, t, r) { this.report(e, ` no '${t}'`, r) } runtimeError(e) { let t = e.token.line; e.token && t ? this.fileName ? console.error(`Erro: [Arquivo: ${this.fileName}] [Linha: ${e.token.line}] ${e.message}`) : console.error(`Erro: [Linha: ${e.token.line}] ${e.message}`) : console.error(e), this.hadRuntimeError = !0 } } }).call(this, J) }), s = { LEFT_PAREN: "LEFT_PAREN", RIGHT_PAREN: "RIGHT_PAREN", LEFT_BRACE: "LEFT_BRACE", RIGHT_BRACE: "RIGHT_BRACE", LEFT_SQUARE_BRACKET: "LEFT_SQUARE_BRACKET", RIGHT_SQUARE_BRACKET: "RIGHT_SQUARE_BRACKET", COMMA: "COMMA", DOT: "DOT", MINUS: "MINUS", PLUS: "PLUS", BIT_AND: "BIT_AND", BIT_OR: "BIT_OR", BIT_XOR: "BIT_XOR", BIT_NOT: "BIT_NOT", COLON: "COLON", SEMICOLON: "SEMICOLON", SLASH: "SLASH", STAR: "STAR", STAR_STAR: "STAR_STAR", MODULUS: "MODULUS", BANG: "BANG", BANG_EQUAL: "BANG_EQUAL", EQUAL: "EQUAL", EQUAL_EQUAL: "EQUAL_EQUAL", GREATER: "GREATER", GREATER_EQUAL: "GREATER_EQUAL", LESS: "LESS", LESS_EQUAL: "LESS_EQUAL", GREATER_GREATER: "GREATER_GREATER", LESSER_LESSER: "LESSER_LESSER", IDENTIFIER: "IDENTIFIER", STRING: "STRING", NUMBER: "NUMBER", E: "E", EM: "EM", CLASSE: "CLASSE", FALSO: "FALSO", FUNCAO: "FUNCAO", PARA: "PARA", SE: "SE", SENAOSE: "SENAOSE", SENAO: "SENAO", ESCOLHA: "ESCOLHA", CASO: "CASO", PADRAO: "PADRAO", NULO: "NULO", OU: "OU", ESCREVA: "ESCREVA", RETORNA: "RETORNA", SUPER: "SUPER", ISTO: "ISTO", VERDADEIRO: "VERDADEIRO", VAR: "VAR", ENQUANTO: "ENQUANTO", PAUSA: "PAUSA", CONTINUA: "CONTINUA", HERDA: "HERDA", IMPORTAR: "IMPORTAR", FACA: "FACA", TENTE: "TENTE", PEGUE: "PEGUE", FINALMENTE: "FINALMENTE", EOF: "EOF" }; const i = { e: s.E, em: s.EM, classe: s.CLASSE, senao: s.SENAO, falso: s.FALSO, para: s.PARA, funcao: s.FUNCAO, se: s.SE, senaose: s.SENAOSE, nulo: s.NULO, ou: s.OU, escreva: s.ESCREVA, retorna: s.RETORNA, super: s.SUPER, isto: s.ISTO, verdadeiro: s.VERDADEIRO, var: s.VAR, faca: s.FACA, enquanto: s.ENQUANTO, pausa: s.PAUSA, continua: s.CONTINUA, escolha: s.ESCOLHA, caso: s.CASO, padrao: s.PADRAO, importar: s.IMPORTAR, tente: s.TENTE, pegue: s.PEGUE, finalmente: s.FINALMENTE, herda: s.HERDA }; class n { constructor(e, t, r, s) { this.type = e, this.lexeme = t, this.literal = r, this.line = s } toString() { return this.type + " " + this.lexeme + " " + this.literal } } var o = class { constructor(e, t) { this.Egua = t, this.code = e, this.tokens = [], this.start = 0, this.current = 0, this.line = 1 } isDigit(e) { return e >= "0" && e <= "9" } isAlpha(e) { return e >= "a" && e <= "z" || e >= "A" && e <= "Z" || "_" == e } isAlphaNumeric(e) { return this.isDigit(e) || this.isAlpha(e) } endOfCode() { return this.current >= this.code.length } advance() { return this.current += 1, this.code[this.current - 1] } addToken(e, t = null) { const r = this.code.substring(this.start, this.current); this.tokens.push(new n(e, r, t, this.line)) } match(e) { return !this.endOfCode() && this.code[this.current] === e && (this.current += 1, !0) } peek() { return this.endOfCode() ? "\0" : this.code.charAt(this.current) } peekNext() { return this.current + 1 >= this.code.length ? "\0" : this.code.charAt(this.current + 1) } previous() { return this.code.charAt(this.current - 1) } parseString(e = '"') { for (; this.peek() !== e && !this.endOfCode();)"\n" === this.peek() && (this.line = 1), this.advance(); if (this.endOfCode()) return void this.Egua.lexerError(this.line, this.previous(), "Texto n\xe3o finalizado."); this.advance(); let t = this.code.substring(this.start + 1, this.current - 1); this.addToken(s.STRING, t) } parseNumber() { for (; this.isDigit(this.peek());)this.advance(); if ("." == this.peek() && this.isDigit(this.peekNext())) for (this.advance(); this.isDigit(this.peek());)this.advance(); const e = this.code.substring(this.start, this.current); this.addToken(s.NUMBER, parseFloat(e)) } identifyKeyword() { for (; this.isAlphaNumeric(this.peek());)this.advance(); const e = this.code.substring(this.start, this.current), t = e in i ? i[e] : s.IDENTIFIER; this.addToken(t) } scanToken() { const e = this.advance(); switch (e) { case "[": this.addToken(s.LEFT_SQUARE_BRACKET); break; case "]": this.addToken(s.RIGHT_SQUARE_BRACKET); break; case "(": this.addToken(s.LEFT_PAREN); break; case ")": this.addToken(s.RIGHT_PAREN); break; case "{": this.addToken(s.LEFT_BRACE); break; case "}": this.addToken(s.RIGHT_BRACE); break; case ",": this.addToken(s.COMMA); break; case ".": this.addToken(s.DOT); break; case "-": this.addToken(s.MINUS); break; case "+": this.addToken(s.PLUS); break; case ":": this.addToken(s.COLON); break; case ";": this.addToken(s.SEMICOLON); break; case "%": this.addToken(s.MODULUS); break; case "*": if ("*" === this.peek()) { this.addToken(s.STAR_STAR), this.advance(); break } this.addToken(s.STAR); break; case "!": this.addToken(this.match("=") ? s.BANG_EQUAL : s.BANG); break; case "=": this.addToken(this.match("=") ? s.EQUAL_EQUAL : s.EQUAL); break; case "&": this.addToken(s.BIT_AND); break; case "~": this.addToken(s.BIT_NOT); break; case "|": this.addToken(s.BIT_OR); break; case "^": this.addToken(s.BIT_XOR); break; case "<": this.match("=") ? this.addToken(s.LESS_EQUAL) : this.match("<") ? this.addToken(s.LESSER_LESSER) : this.addToken(s.LESS); break; case ">": this.match("=") ? this.addToken(s.GREATER_EQUAL) : this.match(">") ? this.addToken(s.GREATER_GREATER) : this.addToken(s.GREATER); break; case "/": if (this.match("/")) for (; "\n" != this.peek() && !this.endOfCode();)this.advance(); else this.addToken(s.SLASH); break; case " ": case "\r": case "\t": break; case "\n": this.line += 1; break; case '"': this.parseString('"'); break; case "'": this.parseString("'"); break; default: this.isDigit(e) ? this.parseNumber() : this.isAlpha(e) ? this.identifyKeyword() : this.Egua.lexerError(this.line, e, "Caractere inesperado.") } } scan() { for (; !this.endOfCode();)this.start = this.current, this.scanToken(); return this.tokens.push(new n(s.EOF, "", null, this.line)), this.tokens } }; class a { accept(e) { } } var h = class extends a { constructor(e, t) { super(), this.name = e, this.value = t } accept(e) { return e.visitAssignExpr(this) } }, c = class extends a { constructor(e, t, r) { super(), this.left = e, this.operator = t, this.right = r } accept(e) { return e.visitBinaryExpr(this) } }, l = class extends a { constructor(e, t) { super(), this.params = e, this.body = t } accept(e) { return e.visitFunctionExpr(this) } }, u = class extends a { constructor(e, t, r) { super(), this.callee = e, this.paren = t, this.args = r } accept(e) { return e.visitCallExpr(this) } }, p = class extends a { constructor(e, t) { super(), this.object = e, this.name = t } accept(e) { return e.visitGetExpr(this) } }, m = class extends a { constructor(e) { super(), this.expression = e } accept(e) { return e.visitGroupingExpr(this) } }, d = class extends a { constructor(e) { super(), this.value = e } accept(e) { return e.visitLiteralExpr(this) } }, E = class extends a { constructor(e) { super(), this.values = e } accept(e) { return e.visitArrayExpr(this) } }, f = class extends a { constructor(e, t) { super(), this.keys = e, this.values = t } accept(e) { return e.visitDictionaryExpr(this) } }, v = class extends a { constructor(e, t, r) { super(), this.callee = e, this.index = t, this.closeBracket = r } accept(e) { return e.visitSubscriptExpr(this) } }, A = class extends a { constructor(e, t, r) { super(), this.obj = e, this.index = t, this.value = r } accept(e) { return e.visitAssignsubscriptExpr(this) } }, S = class extends a { constructor(e, t, r) { super(), this.left = e, this.operator = t, this.right = r } accept(e) { return e.visitLogicalExpr(this) } }, R = class extends a { constructor(e, t, r) { super(), this.object = e, this.name = t, this.value = r } accept(e) { return e.visitSetExpr(this) } }, T = class extends a { constructor(e, t) { super(), this.keyword = e, this.method = t } accept(e) { return e.visitSuperExpr(this) } }, w = class extends a { constructor(e) { super(), this.keyword = e } accept(e) { return e.visitThisExpr(this) } }, N = class extends a { constructor(e, t) { super(), this.operator = e, this.right = t } accept(e) { return e.visitUnaryExpr(this) } }, k = class extends a { constructor(e) { super(), this.name = e } accept(e) { return e.visitVariableExpr(this) } }; class g { accept(e) { } } var x = class extends g { constructor(e) { super(), this.expression = e } accept(e) { return e.visitExpressionStmt(this) } }, O = class extends g { constructor(e, t) { super(), this.name = e, this.func = t } accept(e) { return e.visitFunctionStmt(this) } }, y = class extends g { constructor(e, t) { super(), this.keyword = e, this.value = t } accept(e) { return e.visitReturnStmt(this) } }, b = class extends g { constructor(e, t, r) { super(), this.name = e, this.superclass = t, this.methods = r } accept(e) { return e.visitClassStmt(this) } }, L = class extends g { constructor(e) { super(), this.statements = e } accept(e) { return e.visitBlockStmt(this) } }, I = class extends g { constructor(e) { super(), this.expression = e } accept(e) { return e.visitPrintStmt(this) } }, C = class extends g { constructor(e, t) { super(), this.path = e, this.closeBracket = t } accept(e) { return e.visitImportStmt(this) } }, B = class extends g { constructor(e, t) { super(), this.doBranch = e, this.whileCondition = t } accept(e) { return e.visitDoStmt(this) } }, _ = class extends g { constructor(e, t) { super(), this.condition = e, this.body = t } accept(e) { return e.visitWhileStmt(this) } }, U = class extends g { constructor(e, t, r, s) { super(), this.initializer = e, this.condition = t, this.increment = r, this.body = s } accept(e) { return e.visitForStmt(this) } }, F = class extends g { constructor(e, t, r, s) { super(), this.tryBranch = e, this.catchBranch = t, this.elseBranch = r, this.finallyBranch = s } accept(e) { return e.visitTryStmt(this) } }, G = class extends g { constructor(e, t, r, s) { super(), this.condition = e, this.thenBranch = t, this.elifBranches = r, this.elseBranch = s } accept(e) { return e.visitIfStmt(this) } }, M = class extends g { constructor(e, t, r) { super(), this.condition = e, this.branches = t, this.defaultBranch = r } accept(e) { return e.visitSwitchStmt(this) } }, D = class extends g { constructor() { super() } accept(e) { return e.visitBreakStmt(this) } }, P = class extends g { constructor() { super() } accept(e) { return e.visitContinueStmt(this) } }, V = class extends g { constructor(e, t) { super(), this.name = e, this.initializer = t } accept(e) { return e.visitVarStmt(this) } }; class H extends Error { } var Q = class { constructor(e, t) { this.tokens = e, this.Egua = t, this.current = 0, this.loopDepth = 0 } synchronize() { for (this.advance(); !this.isAtEnd();) { if (this.previous().type == s.SEMICOLON) return; switch (this.peek().type) { case s.CLASSE: case s.FUNCAO: case s.VAR: case s.PARA: case s.SE: case s.ENQUANTO: case s.ESCREVA: case s.RETORNA: return }this.advance() } } error(e, t) { return this.Egua.error(e, t), new H } consume(e, t) { if (this.check(e)) return this.advance(); throw this.error(this.peek(), t) } check(e) { return !this.isAtEnd() && this.peek().type === e } checkNext(e) { return !this.isAtEnd() && this.tokens[this.current + 1].type === e } peek() { return this.tokens[this.current] } previous() { return this.tokens[this.current - 1] } isAtEnd() { return this.peek().type == s.EOF } advance() { return this.isAtEnd() || (this.current += 1), this.previous() } match(...e) { for (let t = 0; t < e.length; t++) { let r = e[t]; if (this.check(r)) return this.advance(), !0 } return !1 } primary() { if (this.match(s.SUPER)) { let e = this.previous(); this.consume(s.DOT, "Esperado '.' ap\xf3s 'super'."); let t = this.consume(s.IDENTIFIER, "Esperado nome do m\xe9todo da superclasse."); return new T(e, t) } if (this.match(s.LEFT_SQUARE_BRACKET)) { let e = []; if (this.match(s.RIGHT_SQUARE_BRACKET)) return new E([]); for (; !this.match(s.RIGHT_SQUARE_BRACKET);) { let t = this.assignment(); e.push(t), this.peek().type !== s.RIGHT_SQUARE_BRACKET && this.consume(s.COMMA, "Esperado v\xedrgula antes da pr\xf3xima express\xe3o.") } return new E(e) } if (this.match(s.LEFT_BRACE)) { let e = [], t = []; if (this.match(s.RIGHT_BRACE)) return new f([], []); for (; !this.match(s.RIGHT_BRACE);) { let r = this.assignment(); this.consume(s.COLON, "Esperado ':' entre chave e valor."); let i = this.assignment(); e.push(r), t.push(i), this.peek().type !== s.RIGHT_BRACE && this.consume(s.COMMA, "Esperado v\xedgula antes da pr\xf3xima express\xe3o.") } return new f(e, t) } if (this.match(s.FUNCAO)) return this.functionBody("funcao"); if (this.match(s.FALSO)) return new d(!1); if (this.match(s.VERDADEIRO)) return new d(!0); if (this.match(s.NULO)) return new d(null); if (this.match(s.ISTO)) return new w(this.previous()); if (this.match(s.IMPORTAR)) return this.importStatement(); if (this.match(s.NUMBER, s.STRING)) return new d(this.previous().literal); if (this.match(s.IDENTIFIER)) return new k(this.previous()); if (this.match(s.LEFT_PAREN)) { let e = this.expression(); return this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3s a express\xe3o."), new m(e) } throw this.error(this.peek(), "Esperado express\xe3o.") } finishCall(e) { let t = []; if (!this.check(s.RIGHT_PAREN)) do { t.length >= 255 && error(this.peek(), "N\xe3o pode haver mais de 255 argumentos."), t.push(this.expression()) } while (this.match(s.COMMA)); let r = this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3s os argumentos."); return new u(e, r, t) } call() { let e = this.primary(); for (; ;)if (this.match(s.LEFT_PAREN)) e = this.finishCall(e); else if (this.match(s.DOT)) { let t = this.consume(s.IDENTIFIER, "Esperado nome do m\xe9todo ap\xf3s '.'."); e = new p(e, t) } else { if (!this.match(s.LEFT_SQUARE_BRACKET)) break; { let t = this.expression(), r = this.consume(s.RIGHT_SQUARE_BRACKET, "Esperado ']' ap\xf3s escrita de index."); e = new v(e, t, r) } } return e } unary() { if (this.match(s.BANG, s.MINUS, s.BIT_NOT)) { let e = this.previous(), t = this.unary(); return new N(e, t) } return this.call() } exponent() { let e = this.unary(); for (; this.match(s.STAR_STAR);) { let t = this.previous(), r = this.unary(); e = new c(e, t, r) } return e } multiplication() { let e = this.exponent(); for (; this.match(s.SLASH, s.STAR, s.MODULUS);) { let t = this.previous(), r = this.exponent(); e = new c(e, t, r) } return e } addition() { let e = this.multiplication(); for (; this.match(s.MINUS, s.PLUS);) { let t = this.previous(), r = this.multiplication(); e = new c(e, t, r) } return e } bitFill() { let e = this.addition(); for (; this.match(s.LESSER_LESSER, s.GREATER_GREATER);) { let t = this.previous(), r = this.addition(); e = new c(e, t, r) } return e } bitAnd() { let e = this.bitFill(); for (; this.match(s.BIT_AND);) { let t = this.previous(), r = this.bitFill(); e = new c(e, t, r) } return e } bitOr() { let e = this.bitAnd(); for (; this.match(s.BIT_OR, s.BIT_XOR);) { let t = this.previous(), r = this.bitAnd(); e = new c(e, t, r) } return e } comparison() { let e = this.bitOr(); for (; this.match(s.GREATER, s.GREATER_EQUAL, s.LESS, s.LESS_EQUAL);) { let t = this.previous(), r = this.bitOr(); e = new c(e, t, r) } return e } equality() { let e = this.comparison(); for (; this.match(s.BANG_EQUAL, s.EQUAL_EQUAL);) { let t = this.previous(), r = this.comparison(); e = new c(e, t, r) } return e } em() { let e = this.equality(); for (; this.match(s.EM);) { let t = this.previous(), r = this.equality(); e = new S(e, t, r) } return e } e() { let e = this.em(); for (; this.match(s.E);) { let t = this.previous(), r = this.em(); e = new S(e, t, r) } return e } ou() { let e = this.e(); for (; this.match(s.OU);) { let t = this.previous(), r = this.e(); e = new S(e, t, r) } return e } assignment() { let e = this.ou(); if (this.match(s.EQUAL)) { let t = this.previous(), r = this.assignment(); if (e instanceof k) { let t = e.name; return new h(t, r) } if (e instanceof p) { let t = e; return new R(t.object, t.name, r) } if (e instanceof v) return new A(e.callee, e.index, r); this.error(t, "Tarefa de atribui\xe7\xe3o inv\xe1lida") } return e } expression() { return this.assignment() } printStatement() { this.consume(s.LEFT_PAREN, "Esperado '(' antes dos valores em escreva."); let e = this.expression(); return this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3s os valores em escreva."), this.consume(s.SEMICOLON, "Esperado ';' ap\xf3s o valor."), new I(e) } expressionStatement() { let e = this.expression(); return this.consume(s.SEMICOLON, "Esperado ';' ap\xf3s express\xe3o."), new x(e) } block() { let e = []; for (; !this.check(s.RIGHT_BRACE) && !this.isAtEnd();)e.push(this.declaration()); return this.consume(s.RIGHT_BRACE, "Esperado '}' ap\xf3s o bloco."), e } ifStatement() { this.consume(s.LEFT_PAREN, "Esperado '(' ap\xf3s 'se'."); let e = this.expression(); this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3s condi\xe7\xe3o do se."); let t = this.statement(), r = []; for (; this.match(s.SENAOSE);) { this.consume(s.LEFT_PAREN, "Esperado '(' ap\xf3s 'senaose'."); let e = this.expression(); this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3es codi\xe7\xe3o do 'senaose."); let t = this.statement(); r.push({ condition: e, branch: t }) } let i = null; return this.match(s.SENAO) && (i = this.statement()), new G(e, t, r, i) } whileStatement() { try { this.loopDepth += 1, this.consume(s.LEFT_PAREN, "Esperado '(' ap\xf3s 'enquanto'."); let e = this.expression(); this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3s condicional."); let t = this.statement(); return new _(e, t) } finally { this.loopDepth -= 1 } } forStatement() { try { let e; this.loopDepth += 1, this.consume(s.LEFT_PAREN, "Esperado '(' ap\xf3s 'para'."), e = this.match(s.SEMICOLON) ? null : this.match(s.VAR) ? this.varDeclaration() : this.expressionStatement(); let t = null; this.check(s.SEMICOLON) || (t = this.expression()), this.consume(s.SEMICOLON, "Esperado ';' ap\xf3s valores da condicional"); let r = null; this.check(s.RIGHT_PAREN) || (r = this.expression()), this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3s cl\xe1usulas"); let i = this.statement(); return new U(e, t, r, i) } finally { this.loopDepth -= 1 } } breakStatement() { return this.loopDepth < 1 && this.error(this.previous(), "'pausa' deve estar dentro de um loop."), this.consume(s.SEMICOLON, "Esperado ';' ap\xf3s 'pausa'."), new D } continueStatement() { return this.loopDepth < 1 && this.error(this.previous(), "'continua' precisa estar em um la\xe7o de repeti\xe7\xe3o."), this.consume(s.SEMICOLON, "Esperado ';' ap\xf3s 'continua'."), new P } returnStatement() { let e = this.previous(), t = null; return this.check(s.SEMICOLON) || (t = this.expression()), this.consume(s.SEMICOLON, "Esperado ';' ap\xf3s o retorno."), new y(e, t) } switchStatement() { try { this.loopDepth += 1, this.consume(s.LEFT_PAREN, "Esperado '{' ap\xf3s 'escolha'."); let e = this.expression(); this.consume(s.RIGHT_PAREN, "Esperado '}' ap\xf3s a condi\xe7\xe3o de 'escolha'."), this.consume(s.LEFT_BRACE, "Esperado '{' antes do escopo do 'escolha'."); let t = [], r = null; for (; !this.match(s.RIGHT_BRACE) && !this.isAtEnd();)if (this.match(s.CASO)) { let e = [this.expression()]; for (this.consume(s.COLON, "Esperado ':' ap\xf3s o 'caso'."); this.check(s.CASO);)this.consume(s.CASO, null), e.push(this.expression()), this.consume(s.COLON, "Esperado ':' ap\xf3s declara\xe7\xe3o do 'caso'."); let r = []; do { r.push(this.statement()) } while (!this.check(s.CASO) && !this.check(s.PADRAO) && !this.check(s.RIGHT_BRACE)); t.push({ conditions: e, stmts: r }) } else if (this.match(s.PADRAO)) { if (null !== r) throw new H("Voc\xea s\xf3 pode ter um 'padrao' em cada declara\xe7\xe3o de 'escolha'."); this.consume(s.COLON, "Esperado ':' ap\xf3s declara\xe7\xe3o do 'padrao'."); let e = []; do { e.push(this.statement()) } while (!this.check(s.CASO) && !this.check(s.PADRAO) && !this.check(s.RIGHT_BRACE)); r = { stmts: e } } return new M(e, t, r) } finally { this.loopDepth -= 1 } } importStatement() { this.consume(s.LEFT_PAREN, "Esperado '(' ap\xf3s declara\xe7\xe3o."); let e = this.expression(), t = this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3s declara\xe7\xe3o."); return new C(e, t) } tryStatement() { this.consume(s.LEFT_BRACE, "Esperado '{' ap\xf3s a declara\xe7\xe3o 'tente'."); let e = this.block(), t = null; this.match(s.PEGUE) && (this.consume(s.LEFT_BRACE, "Esperado '{' ap\xf3s a declara\xe7\xe3o 'pegue'."), t = this.block()); let r = null; this.match(s.SENAO) && (this.consume(s.LEFT_BRACE, "Esperado '{' ap\xf3s a declara\xe7\xe3o 'pegue'."), r = this.block()); let i = null; return this.match(s.FINALMENTE) && (this.consume(s.LEFT_BRACE, "Esperado '{' ap\xf3s a declara\xe7\xe3o 'pegue'."), i = this.block()), new F(e, t, r, i) } doStatement() { try { this.loopDepth += 1; let e = this.statement(); this.consume(s.ENQUANTO, "Esperado delcara\xe7\xe3o do 'enquanto' ap\xf3s o escopo do 'faca'."), this.consume(s.LEFT_PAREN, "Esperado '(' ap\xf3s declara\xe7\xe3o 'enquanto'."); let t = this.expression(); return this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3s declara\xe7\xe3o do 'enquanto'."), new B(e, t) } finally { this.loopDepth -= 1 } } statement() { return this.match(s.FACA) ? this.doStatement() : this.match(s.TENTE) ? this.tryStatement() : this.match(s.ESCOLHA) ? this.switchStatement() : this.match(s.RETORNA) ? this.returnStatement() : this.match(s.CONTINUA) ? this.continueStatement() : this.match(s.PAUSA) ? this.breakStatement() : this.match(s.PARA) ? this.forStatement() : this.match(s.ENQUANTO) ? this.whileStatement() : this.match(s.SE) ? this.ifStatement() : this.match(s.ESCREVA) ? this.printStatement() : this.match(s.LEFT_BRACE) ? new L(this.block()) : this.expressionStatement() } varDeclaration() { let e = this.consume(s.IDENTIFIER, "Esperado nome de vari\xe1vel."), t = null; return this.match(s.EQUAL) && (t = this.expression()), this.consume(s.SEMICOLON, "Esperado ';' ap\xf3s a declara\xe7\xe3o da vari\xe1vel."), new V(e, t) } function(e) { let t = this.consume(s.IDENTIFIER, `Esperado nome ${e}.`); return new O(t, this.functionBody(e)) } functionBody(e) { this.consume(s.LEFT_PAREN, `Esperado '(' ap\xf3s o nome ${e}.`); let t = []; if (!this.check(s.RIGHT_PAREN)) do { t.length >= 255 && this.error(this.peek(), "N\xe3o pode haver mais de 255 par\xe2metros"); let e = {}; if (this.peek().type === s.STAR ? (this.consume(s.STAR, null), e.type = "wildcard") : e.type = "standard", e.name = this.consume(s.IDENTIFIER, "Expect parameter name."), this.match(s.EQUAL) && (e.default = this.primary()), t.push(e), "wildcard" === e.type) break } while (this.match(s.COMMA)); this.consume(s.RIGHT_PAREN, "Esperado ')' ap\xf3s par\xe2metros."), this.consume(s.LEFT_BRACE, `Esperado '{' antes do escopo ${e}.`); let r = this.block(); return new l(t, r) } classDeclaration() { let e = this.consume(s.IDENTIFIER, "Esperado nome da classe."), t = null; this.match(s.HERDA) && (this.consume(s.IDENTIFIER, "Esperado nome da superclasse."), t = new k(this.previous())), this.consume(s.LEFT_BRACE, "Esperado '{' antes do escopo da classe."); let r = []; for (; !this.check(s.RIGHT_BRACE) && !this.isAtEnd();)r.push(this.function("method")); return this.consume(s.RIGHT_BRACE, "Esperado '}' ap\xf3s o escopo da classe."), new b(e, t, r) } declaration() { try { return this.check(s.FUNCAO) && this.checkNext(s.IDENTIFIER) ? (this.consume(s.FUNCAO, null), this.function("funcao")) : this.match(s.VAR) ? this.varDeclaration() : this.match(s.CLASSE) ? this.classDeclaration() : this.statement() } catch (error) { return this.synchronize(), null } } parse() { let e = []; for (; !this.isAtEnd();)e.push(this.declaration()); return e } }; class $ extends Error { constructor(e) { super(e), this.message = e } } class j { constructor() { this.stack = [] } push(e) { this.stack.push(e) } isEmpty() { return 0 === this.stack.length } peek() { if (this.isEmpty()) throw new Error("Pilha vazia."); return this.stack[this.stack.length - 1] } pop() { if (this.isEmpty()) throw new Error("Pilha vazia."); return this.stack.pop() } } var z = class { constructor(e, t) { this.interpreter = e, this.egua = t, this.scopes = new j, this.currentFunction = "NONE", this.currentClass = "NONE", this.currentLoop = "NONE" } define(e) { this.scopes.isEmpty() || (this.scopes.peek()[e.lexeme] = !0) } declare(e) { if (this.scopes.isEmpty()) return; let t = this.scopes.peek(); t.hasOwnProperty(e.lexeme) && this.egua.error(e, "Vari\xe1vel com esse nome j\xe1 declarada neste escopo."), t[e.lexeme] = !1 } beginScope() { this.scopes.push({}) } endScope() { this.scopes.pop() } resolve(e) { if (Array.isArray(e)) for (let t = 0; t < e.length; t++)e[t].accept(this); else e.accept(this) } resolveLocal(e, t) { for (let r = this.scopes.stack.length - 1; r >= 0; r--)this.scopes.stack[r].hasOwnProperty(t.lexeme) && this.interpreter.resolve(e, this.scopes.stack.length - 1 - r) } visitBlockStmt(e) { return this.beginScope(), this.resolve(e.statements), this.endScope(), null } visitVariableExpr(e) { if (!this.scopes.isEmpty() && !1 === this.scopes.peek()[e.name.lexeme]) throw new $("N\xe3o \xe9 poss\xedvel ler a vari\xe1vel local em seu pr\xf3prio inicializador."); return this.resolveLocal(e, e.name), null } visitVarStmt(e) { return this.declare(e.name), null !== e.initializer && this.resolve(e.initializer), this.define(e.name), null } visitAssignExpr(e) { return this.resolve(e.value), this.resolveLocal(e, e.name), null } resolveFunction(e, t) { let r = this.currentFunction; this.currentFunction = t, this.beginScope(); let s = e.params; for (let i = 0; i < s.length; i++)this.declare(s[i].name), this.define(s[i].name); this.resolve(e.body), this.endScope(), this.currentFunction = r } visitFunctionStmt(e) { return this.declare(e.name), this.define(e.name), this.resolveFunction(e.func, "FUNCAO"), null } visitFunctionExpr(e) { return this.resolveFunction(e, "FUNCAO"), null } visitTryStmt(e) { this.resolve(e.tryBranch), null !== e.catchBranch && this.resolve(e.catchBranch), null !== e.elseBranch && this.resolve(e.elseBranch), null !== e.finallyBranch && this.resolve(e.finallyBranch) } visitClassStmt(e) { let t = this.currentClass; this.currentClass = "CLASSE", this.declare(e.name), this.define(e.name), null !== e.superclass && e.name.lexeme === e.superclass.name.lexeme && this.egua.error("Uma classe n\xe3o pode herdar de si mesma."), null !== e.superclass && (this.currentClass = "SUBCLASS", this.resolve(e.superclass)), null !== e.superclass && (this.beginScope(), this.scopes.peek().super = !0), this.beginScope(), this.scopes.peek().isto = !0; let r = e.methods; for (let s = 0; s < r.length; s++) { let e = "METHOD"; "isto" === r[s].name.lexeme && (e = "CONSTRUTOR"), this.resolveFunction(r[s].func, e) } return this.endScope(), null !== e.superclass && this.endScope(), this.currentClass = t, null } visitSuperExpr(e) { return "NONE" === this.currentClass ? this.egua.error(e.keyword, "N\xe3o pode usar 'super' fora de uma classe.") : "SUBCLASS" !== this.currentClass && this.egua.error(e.keyword, "N\xe3o se usa 'super' numa classe sem superclasse."), this.resolveLocal(e, e.keyword), null } visitGetExpr(e) { return this.resolve(e.object), null } visitExpressionStmt(e) { return this.resolve(e.expression), null } visitIfStmt(e) { this.resolve(e.condition), this.resolve(e.thenBranch); for (let t = 0; t < e.elifBranches.length; t++)this.resolve(e.elifBranches[t].condition), this.resolve(e.elifBranches[t].branch); return null !== e.elseBranch && this.resolve(e.elseBranch), null } visitImportStmt(e) { this.resolve(e.path) } visitPrintStmt(e) { this.resolve(e.expression) } visitReturnStmt(e) { return "NONE" === this.currentFunction && this.egua.error(e.keyword, "N\xe3o \xe9 poss\xedvel retornar do c\xf3digo do escopo superior."), null !== e.value && ("CONSTRUTOR" === this.currentFunction && this.egua.error(e.keyword, "N\xe3o pode retornar o valor do construtor."), this.resolve(e.value)), null } visitSwitchStmt(e) { let t = this.currentLoop; this.currentLoop = "ESCOLHA"; let r = e.branches, s = e.defaultBranch; for (let i = 0; i < r.length; i++)this.resolve(r[i].stmts); null !== s && this.resolve(s.stmts), this.currentLoop = t } visitWhileStmt(e) { return this.resolve(e.condition), this.resolve(e.body), null } visitForStmt(e) { null !== e.initializer && this.resolve(e.initializer), null !== e.condition && this.resolve(e.condition), null !== e.increment && this.resolve(e.increment); let t = this.currentLoop; return this.currentLoop = "ENQUANTO", this.resolve(e.body), this.currentLoop = t, null } visitDoStmt(e) { this.resolve(e.whileCondition); let t = this.currentLoop; return this.currentLoop = "FACA", this.resolve(e.doBranch), this.currentLoop = t, null } visitBinaryExpr(e) { return this.resolve(e.left), this.resolve(e.right), null } visitCallExpr(e) { this.resolve(e.callee); let t = e.args; for (let r = 0; r < t.length; r++)this.resolve(t[r]); return null } visitGroupingExpr(e) { return this.resolve(e.expression), null } visitDictionaryExpr(e) { for (let t = 0; t < e.keys.length; t++)this.resolve(e.keys[t]), this.resolve(e.values[t]); return null } visitArrayExpr(e) { for (let t = 0; t < e.values.length; t++)this.resolve(e.values[t]); return null } visitSubscriptExpr(e) { return this.resolve(e.callee), this.resolve(e.index), null } visitContinueStmt(e) { return null } visitBreakStmt(e) { return null } visitAssignsubscriptExpr(e) { return null } visitLiteralExpr(e) { return null } visitLogicalExpr(e) { return this.resolve(e.left), this.resolve(e.right), null } visitUnaryExpr(e) { return this.resolve(e.right), null } visitSetExpr(e) { return this.resolve(e.value), this.resolve(e.object), null } visitThisExpr(e) { return "NONE" == this.currentClass && this.egua.error(e.keyword, "N\xe3o pode usar 'isto' fora da classe."), this.resolveLocal(e, e.keyword), null } }, q = {}; q.RuntimeError = class extends Error { constructor(e, t) { super(t), this.token = e } }, q.ContinueException = class extends Error { }, q.BreakException = class extends Error { }, q.ReturnException = class extends Error { constructor(e) { super(e), this.value = e } }; const K = q.RuntimeError; var X, W, Z = class { constructor(e) { this.enclosing = e || null, this.values = {} } defineVar(e, t) { this.values[e] = t } assignVarAt(e, t, r) { this.ancestor(e).values[t.lexeme] = r } assignVar(e, t) { if (void 0 === this.values[e.lexeme]) { if (null == this.enclosing) throw new K(e, "Vari\xe1vel n\xe3o definida '" + e.lexeme + "'."); this.enclosing.assignVar(e, t) } else this.values[e.lexeme] = t } ancestor(e) { let t = this; for (let r = 0; r < e; r++)t = t.enclosing; return t } getVarAt(e, t) { return this.ancestor(e).values[t] } getVar(e) { if (void 0 !== this.values[e.lexeme]) return this.values[e.lexeme]; if (null !== this.enclosing) return this.enclosing.getVar(e); throw new K(e, "Vari\xe1vel n\xe3o definida '" + e.lexeme + "'.") } }, J = {}, Y = J = {}; function ee() { throw new Error("setTimeout has not been defined") } function te() { throw new Error("clearTimeout has not been defined") } function re(e) { if (X === setTimeout) return setTimeout(e, 0); if ((X === ee || !X) && setTimeout) return X = setTimeout, setTimeout(e, 0); try { return X(e, 0) } catch (t) { try { return X.call(null, e, 0) } catch (t) { return X.call(this, e, 0) } } } !function () { try { X = "function" == typeof setTimeout ? setTimeout : ee } catch (e) { X = ee } try { W = "function" == typeof clearTimeout ? clearTimeout : te } catch (e) { W = te } }(); var se, ie = [], ne = !1, oe = -1; function ae() { ne && se && (ne = !1, se.length ? ie = se.concat(ie) : oe = -1, ie.length && he()) } function he() { if (!ne) { var e = re(ae); ne = !0; for (var t = ie.length; t;) { for (se = ie, ie = []; ++oe < t;)se && se[oe].run(); oe = -1, t = ie.length } se = null, ne = !1, function (e) { if (W === clearTimeout) return clearTimeout(e); if ((W === te || !W) && clearTimeout) return W = clearTimeout, clearTimeout(e); try { W(e) } catch (t) { try { return W.call(null, e) } catch (t) { return W.call(this, e) } } }(e) } } function ce(e, t) { this.fun = e, this.array = t } function le() { } Y.nextTick = function (e) { var t = new Array(arguments.length - 1); if (arguments.length > 1) for (var r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; ie.push(new ce(e, t)), 1 !== ie.length || ne || re(he) }, ce.prototype.run = function () { this.fun.apply(null, this.array) }, Y.title = "browser", Y.browser = !0, Y.env = {}, Y.argv = [], Y.version = "", Y.versions = {}, Y.on = le, Y.addListener = le, Y.once = le, Y.off = le, Y.removeListener = le, Y.removeAllListeners = le, Y.emit = le, Y.prependListener = le, Y.prependOnceListener = le, Y.listeners = function (e) { return [] }, Y.binding = function (e) { throw new Error("process.binding is not supported") }, Y.cwd = function () { return "/" }, Y.chdir = function (e) { throw new Error("process.chdir is not supported") }, Y.umask = function () { return 0 }; var ue = {}; (function (e) { function t(e, t) { for (var r = 0, s = e.length - 1; s >= 0; s--) { var i = e[s]; "." === i ? e.splice(s, 1) : ".." === i ? (e.splice(s, 1), r++) : r && (e.splice(s, 1), r--) } if (t) for (; r--; r)e.unshift(".."); return e } function r(e, t) { if (e.filter) return e.filter(t); for (var r = [], s = 0; s < e.length; s++)t(e[s], s, e) && r.push(e[s]); return r } ue.resolve = function () { for (var s = "", i = !1, n = arguments.length - 1; n >= -1 && !i; n--) { var o = n >= 0 ? arguments[n] : e.cwd(); if ("string" != typeof o) throw new TypeError("Arguments to path.resolve must be strings"); o && (s = o + "/" + s, i = "/" === o.charAt(0)) } return (i ? "/" : "") + (s = t(r(s.split("/"), function (e) { return !!e }), !i).join("/")) || "." }, ue.normalize = function (e) { var i = ue.isAbsolute(e), n = "/" === s(e, -1); return (e = t(r(e.split("/"), function (e) { return !!e }), !i).join("/")) || i || (e = "."), e && n && (e += "/"), (i ? "/" : "") + e }, ue.isAbsolute = function (e) { return "/" === e.charAt(0) }, ue.join = function () { var e = Array.prototype.slice.call(arguments, 0); return ue.normalize(r(e, function (e, t) { if ("string" != typeof e) throw new TypeError("Arguments to path.join must be strings"); return e }).join("/")) }, ue.relative = function (e, t) { function r(e) { for (var t = 0; t < e.length && "" === e[t]; t++); for (var r = e.length - 1; r >= 0 && "" === e[r]; r--); return t > r ? [] : e.slice(t, r - t + 1) } e = ue.resolve(e).substr(1), t = ue.resolve(t).substr(1); for (var s = r(e.split("/")), i = r(t.split("/")), n = Math.min(s.length, i.length), o = n, a = 0; a < n; a++)if (s[a] !== i[a]) { o = a; break } var h = []; for (a = o; a < s.length; a++)h.push(".."); return (h = h.concat(i.slice(o))).join("/") }, ue.sep = "/", ue.delimiter = ":", ue.dirname = function (e) { if ("string" != typeof e && (e += ""), 0 === e.length) return "."; for (var t = e.charCodeAt(0), r = 47 === t, s = -1, i = !0, n = e.length - 1; n >= 1; --n)if (47 === (t = e.charCodeAt(n))) { if (!i) { s = n; break } } else i = !1; return -1 === s ? r ? "/" : "." : r && 1 === s ? "/" : e.slice(0, s) }, ue.basename = function (e, t) { var r = function (e) { "string" != typeof e && (e += ""); var t, r = 0, s = -1, i = !0; for (t = e.length - 1; t >= 0; --t)if (47 === e.charCodeAt(t)) { if (!i) { r = t + 1; break } } else -1 === s && (i = !1, s = t + 1); return -1 === s ? "" : e.slice(r, s) }(e); return t && r.substr(-1 * t.length) === t && (r = r.substr(0, r.length - t.length)), r }, ue.extname = function (e) { "string" != typeof e && (e += ""); for (var t = -1, r = 0, s = -1, i = !0, n = 0, o = e.length - 1; o >= 0; --o) { var a = e.charCodeAt(o); if (47 !== a) -1 === s && (i = !1, s = o + 1), 46 === a ? -1 === t ? t = o : 1 !== n && (n = 1) : -1 !== t && (n = -1); else if (!i) { r = o + 1; break } } return -1 === t || -1 === s || 0 === n || 1 === n && t === s - 1 && t === r + 1 ? "" : e.slice(t, s) }; var s = "b" === "ab".substr(-1) ? function (e, t, r) { return e.substr(t, r) } : function (e, t, r) { return t < 0 && (t = e.length + t), e.substr(t, r) } }).call(this, J); var pe = {}, me = class { arity() { return this.arityValue } }; const de = q.ReturnException; var Ee = class e extends me { constructor(e, t, r, s = !1) { super(), this.name = e, this.declaration = t, this.closure = r, this.isInitializer = s } arity() { return this.declaration.params.length } toString() { return null === this.name ? "<fun\xe7\xe3o>" : `<fun\xe7\xe3o ${this.name}>` } call(e, t) { let r = new Z(this.closure), s = this.declaration.params; for (let i = 0; i < s.length; i++) { let e = s[i], n = e.name.lexeme, o = t[i]; null === t[i] && (o = e.default ? e.default.value : null), r.defineVar(n, o) } try { e.executeBlock(this.declaration.body, r) } catch (error) { if (error instanceof de) return this.isInitializer ? this.closure.getVarAt(0, "isto") : error.value; throw error } return this.isInitializer ? this.closure.getVarAt(0, "isto") : null } bind(t) { let r = new Z(this.closure); return r.defineVar("isto", t), new e(this.name, this.declaration, r, this.isInitializer) } }, fe = class { constructor(e) { this.creatorClass = e, this.fields = {} } get(e) { if (this.fields.hasOwnProperty(e.lexeme)) return this.fields[e.lexeme]; let t = this.creatorClass.findMethod(e.lexeme); if (t) return t.bind(this); throw new RuntimeError(e, "M\xe9todo indefinido n\xe3o recuperado.") } set(e, t) { this.fields[e.lexeme] = t } toString() { return "<" + this.creatorClass.name + " inst\xe2ncia>" } }, ve = class extends me { constructor(e, t) { super(), this.arityValue = e, this.func = t } call(e, t, r) { return this.token = r, this.func.apply(this, t) } toString() { return "<fun\xe7\xe3o>" } }, Ae = class extends me { constructor(e, t, r) { super(), this.name = e, this.superclass = t, this.methods = r } findMethod(e) { return this.methods.hasOwnProperty(e) ? this.methods[e] : null !== this.superclass ? this.superclass.findMethod(e) : void 0 } toString() { return `<classe ${this.name}>` } arity() { let e = this.findMethod("construtor"); return e ? e.arity() : 0 } call(e, t) { let r = new fe(this), s = this.findMethod("construtor"); return s && s.bind(r).call(e, t), r } }; const Se = q.RuntimeError; var Re = function (e) { return e.defineVar("tamanho", new ve(1, function (e) { if (!isNaN(e)) throw new Se(this.token, "N\xe3o \xe9 poss\xedvel encontrar o tamanho de um n\xfamero."); if (e instanceof fe) throw new Se(this.token, "Voc\xea n\xe3o pode encontrar o tamanho de uma declara\xe7\xe3o."); if (e instanceof Ee) return e.declaration.params.length; if (e instanceof ve) return e.arityValue; if (e instanceof Ae) { let t = e.methods, r = 0; return t.init && t.init.isInitializer && (r = t.init.declaration.params.length), r } return e.length })), e.defineVar("texto", new ve(1, function (e) { return `${e}` })), e.defineVar("real", new ve(1, function (e) { if (!/^-{0,1}\d+$/.test(e) && !/^\d+\.\d+$/.test(e)) throw new Se(this.token, "Somente n\xfameros podem passar para real."); return parseFloat(e) })), e.defineVar("inteiro", new ve(1, function (e) { if (null == e) throw new Se(this.token, "Somente n\xfameros podem passar para inteiro."); if (!/^-{0,1}\d+$/.test(e) && !/^\d+\.\d+$/.test(e)) throw new Se(this.token, "Somente n\xfameros podem passar para inteiro."); return parseInt(e) })), e.defineVar("exports", {}), e }, Te = class { constructor(e) { void 0 !== e && (this.name = e) } toString() { return this.name ? `<module ${this.name}>` : "<module>" } }, we = {}; const Ne = q.RuntimeError; we.aprox = function (e) { if (isNaN(e) || null === e) throw new Ne(this.token, "Voc\xea deve prover um n\xfamero para mat.aprox(n\xfamero)."); return Math.round(e) }, we.raizq = function (e) { if (isNaN(e) || null === e) throw new Ne(this.token, "Voc\xea deve prover um n\xfamero para mat.raizq(n\xfamero)."); return Math.sqrt(e) }, we.sen = function (e) { if (isNaN(e) || null === e) throw new Ne(this.token, "Voc\xea deve prover um n\xfamero para mat.sen(n\xfamero)."); return Math.sin(e) }, we.cos = function (e) { if (isNaN(e) || null === e) throw new Ne(this.token, "Voc\xea deve prover um n\xfamero para mat.cos(n\xfamero)."); return Math.cos(e) }, we.tan = function (e) { if (isNaN(e) || null === e) throw new Ne(this.token, "Voc\xea deve prover um n\xfamero para mat.tan(n\xfamero)."); return Math.tan(e) }, we.radiano = function (e) { if (isNaN(e) || null === e) throw new Ne(this.token, "Voc\xea deve prover um n\xfamero para mat.radiano(\xc2ngulo)."); return e * (Math.PI / 180) }, we.graus = function (e) { if (isNaN(e) || null === e) throw new Ne(this.token, "Voc\xea deve prover um n\xfamero para mat.graus(\xe2ngulo)."); return e * (180 / Math.PI) }, we.pi = Math.PI, we.raiz = function (e, t) { if (isNaN(e) || null === e) throw new Ne(this.token, "N\xfamero dado a mat.raiz(numero, raiz) precisa ser um n\xfamero."); if (isNaN(t) || null === t) throw new Ne(this.token, "Raiz dada a mat.raiz(numero, raiz) precisa ser um n\xfamero."); let r = t, s = t % 2 == 1 && e < 0; s && (e = -e); let i = Math.pow(e, 1 / t); if (t = Math.pow(i, t), Math.abs(e - t) < 1 && e > 0 == t > 0) return s ? -i : i; throw new Ne(this.token, `Erro ao encontrar a raiz ${r} de ${e}.`) }; var ke = {}; const ge = q.RuntimeError; ke.ler = function (e, t = "utf-8") { if (null === e) throw new ge(this.token, "Voc\xea deve prover o caminho do arquivo para os.ler(caminho)."); try { return pe.readFileSync(e, t) } catch (error) { throw new ge(this.token, `Erro ao ler o arquivo - ${error.code}.`) } }, ke.escreva = function (e, t = "", r = "utf-8") { if (null === e) throw new ge(this.token, "Voc\xea deve prover o caminho do arquivo para os.escreva(arquivo)."); try { return pe.writeFileSync(e, t, r), null } catch (error) { throw new ge(this.token, `Erro ao escrever o arquivo - ${error.code}.`) } }, ke.apagar = function (e) { if (null === e) throw new ge(this.token, "Voc\xea deve prover o caminho do arquivo para os.apagar(arquivo)."); try { return pe.unlinkSync(e), null } catch (error) { throw new ge(this.token, `Erro ao apagar o arquivo - ${error.code}.`) } }, ke.criardir = function (e) { if (null === e) throw new ge(this.token, "Voc\xea deve prover o caminho do diret\xf3rio para os.criardir(arquivo)."); try { return pe.mkdirSync(e), null } catch (error) { throw new ge(this.token, `Erro ao criar o diret\xf3rio - ${error.code}.`) } }, ke.apagardir = function (e) { if (null === e) throw new ge(this.token, "Voc\xea deve prover o caminho do diret\xf3rio para os.apagardir(arquivo)."); try { return pe.rmdirSync(e, { recursive: !0 }), null } catch (error) { throw new ge(this.token, `Erro ao apagar o diret\xf3rio - ${error.code}.`) } }, ke.listardir = function (e) { if (null === e) throw new ge(this.token, "Voc\xea deve prover o caminho do diret\xf3rio para os.listdir(listardir)."); try { return pe.readdirSync(e) } catch (error) { throw new ge(this.token, `Erro ao listar o conte\xfado do diret\xf3rio - ${error.code}.`) } }; var xe = {}; const Oe = function (e, t) { let r = require(t), s = new Te(e), i = Object.keys(r); for (let n = 0; n < i.length; n++) { let e = r[i[n]]; s[i[n]] = "function" == typeof e ? new ve(e.length, e) : e } return s }; xe = function (e) { switch (e) { case "os": return Oe("os", "./os.js"); case "time": return Oe("os", "./time.js"); case "eguamat": return Oe("eguamat", "./eguamat.js") }return null }; var ye = {}; return function (e) { const r = t({}); ye.Egua = class { constructor(e) { this.filename = e, this.hadError = !1, this.hadRuntimeError = !1 } runBlock(t) { const s = new r(this, e.cwd()), i = new o(t, this).scan(); if (!0 === this.hadError) return; const n = new Q(i, this).parse(); !0 !== this.hadError && (new z(s, this).resolve(n), !0 !== this.hadError && s.interpret(n)) } report(e, t, r) { this.filename ? console.error(`[Arquivo: ${this.filename}] [Linha: ${e}] Erro${t}: ${r}`) : console.error(`[Linha: ${e}] Erro${t}: ${r}`), this.hadError = !0 } error(e, t) { e.type === s.EOF ? this.report(e.line, " no fim", t) : this.report(e.line, ` no '${e.lexeme}'`, t) } lexerError(e, t, r) { this.report(e, ` no '${t}'`, r) } runtimeError(e) { let t = e.token.line; e.token && t ? this.filename ? console.error(`Erro: [Arquivo: ${this.filename}] [Linha: ${e.token.line}] ${e.message}`) : console.error(`Erro: [Linha: ${e.token.line}] ${e.message}`) : console.error(e), this.hadRuntimeError = !0 } } }.call(this, J), ye });